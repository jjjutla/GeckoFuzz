const hex_to_number = (hex: string) : number => {
    return parseInt(hex, 16);
}

const peek_future = (raw: Buffer, bytecode: number, max_instr: number, offset: number) : boolean => {
    if (offset + max_instr >= raw.length) {
        return false;
    }
    for (let i = 0; i < max_instr; i++) {
        if (raw[offset + i] === bytecode) {
            return true;
        }
    }
    return false;
}

const extract_callable_funcs_from_bytecode = (raw: Buffer) : Buffer[] => {
    let callable_hashes : Buffer[] = [];
    // console.log(raw, raw.length);

    for (let i = 0; i < raw.length; i += 1) {

        let currentData = raw[i];

        if (0x60 <= currentData && currentData <= 0x7f) {
            // console.log("Found PUSH");
            const want_to_push = currentData - 0x60 + 1;
            const new_offset = i + want_to_push;
            if (want_to_push === 4
                && peek_future(raw, 0x14, 2, new_offset)
                && peek_future(raw, 0x61, 3, new_offset)
                && peek_future(raw, 0x57, 6, new_offset)
            ) {
                const hash = raw.subarray(i + 1, i + 5);
                callable_hashes.push(hash);
            }
            i = new_offset
        }
    }
    return callable_hashes;
}
//
// extract_callable_funcs_from_bytecode(Buffer.from(
//     "608060405234801561001057600080fd5b50610334806100206000396000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806302e4691a1461003b5780639507d39a14610059575b600080fd5b610043610089565b604051610050919061015d565b60405180910390f35b610073600480360381019061006e91906101b3565b6100a7565b6040516100809190610270565b60405180910390f35b60006002600080606081526020019081526020016000205414905090565b60608160008060608152602001908152602001600020819055506002821015610105576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016100fc906102de565b60405180910390fd5b6040518060400160405280600f81526020017f48656c6c6f20436f6e74726163747300000000000000000000000000000000008152509050919050565b60008115159050919050565b61015781610142565b82525050565b6000602082019050610172600083018461014e565b92915050565b600080fd5b6000819050919050565b6101908161017d565b811461019b57600080fd5b50565b6000813590506101ad81610187565b92915050565b6000602082840312156101c9576101c8610178565b5b60006101d78482850161019e565b91505092915050565b600081519050919050565b600082825260208201905092915050565b60005b8381101561021a5780820151818401526020810190506101ff565b60008484015250505050565b6000601f19601f8301169050919050565b6000610242826101e0565b61024c81856101eb565b935061025c8185602086016101fc565b61026581610226565b840191505092915050565b6000602082019050818103600083015261028a8184610237565b905092915050565b7f6675636b00000000000000000000000000000000000000000000000000000000600082015250565b60006102c86004836101eb565b91506102d382610292565b602082019050919050565b600060208201905081810360008301526102f7816102bb565b905091905056fea26469706673582212208ad04c322dbf770e289d767af7a747c29c969383ef9e4c099b28a08bf7a868d364736f6c63430008110033",
//     "hex"
// )).forEach((x) => console.log(x.toString("hex")))

export {
    extract_callable_funcs_from_bytecode
}
